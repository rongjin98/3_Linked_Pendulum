function zdot = manipulator(t, z_0)theta_1 = z_0(1);theta_2 = z_0(2);theta_dot_1 = z_0(3);theta_dot_2 = z_0(4);params;% Inertia matrixb11 = I_l1 + m_l1*l_1^2+kr_1^2*I_m1+I_l2+m_l2*(a_1^2+l_2^2+2*a_1*l_2*cos(theta_2)) + I_m2 + m_m2*a_1^2;b12 = I_l2+m_l2*(l_2^2+a_1*l_2*cos(theta_2))+kr_2*I_m2;b21 = b12;b22 = I_l2+ m_l2*l_2^2+kr_2^2*I_m2;% Christoffel symbols c111 = 0;c112 = -m_l2*a_1*l_2*sin(theta_2);c122 = c112;c211 = -c112;c212 = 0;c222 = 0;h = c112;% Gravity termsg11 = (m_l1*l_1+m_m2*a_1+m_l2*a_1)*g*cos(theta_1) + m_l2*l_2*g*cos(theta_1+theta_2);g22 = m_l2*l_2*g*cos(theta_1+theta_2);% Assemble manipulator dynamicsB = [b11 b12; b21 b22];C = [h*theta_dot_2 h*(theta_dot_1+theta_dot_2); -h*theta_dot_1 0];N = [2*h*theta_dot_2 h*theta_dot_2; h*theta_dot_2 0]-2*[h*theta_dot_2 h*(theta_dot_1+theta_dot_2); -h*theta_dot_1 0];G = [g11; g22];% Jacobian Analyticalj11 = -a_2*sin(theta_1+theta_2)-a_1*sin(theta_1);j12 = -a_2*sin(theta_1+theta_2);j21 = a_2*cos(theta_1+theta_2)+a_1*cos(theta_1);j22 = a_2*cos(theta_1+theta_2);Ja = [j11 j12; j21 j22];% Derivative of Jacobian Analyticals1 = a_2*sin(theta_1+theta_2)*(theta_dot_1+theta_dot_2);s2 = a_2*cos(theta_1+theta_2)*(theta_dot_1+theta_dot_2);jd11 = -s2-a_1*cos(theta_1)*theta_dot_1;jd12 = -s2;jd21 = -s1-a_1*sin(theta_1)*theta_dot_1;jd22 = -s1;Ja_dot = [jd11 jd12; jd21 jd22];% Define joint variableq = [theta_1 theta_2]';q_dot = [theta_dot_1 theta_dot_2]';% Get desired variablesXd = [1; 0.5];Xd_dot = [0;0];Xd_ddot = [0;0];% Define operational space variables Xe = fk(q);Xe_dot = Ja*q_dot;X_tilda = Xd-Xe;X_tilda_dot = Xd_dot-Xe_dot;% Inverse dynamics operational space controllery = Ja\(Xd_ddot+Kd*X_tilda_dot+Kp*X_tilda-Ja_dot*q_dot);% Inverse dynamics linearizing controlu = B*y+C*q_dot+Fv*q_dot+G*(0.99);RHS =u-C*q_dot-Fv*q_dot-G ;LHS = B;q_ddot = LHS\RHS;theta_ddot_1 = q_ddot(1);theta_ddot_2 = q_ddot(2);zdot = [theta_dot_1; theta_dot_2; theta_ddot_1; theta_ddot_2];end